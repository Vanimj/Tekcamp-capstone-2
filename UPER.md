                                    The Problem Solving Framework : UPER

* U = "Understand"
* P = "Plan"
* E = "Execute"
* R = "Reflect" / "Refactor"

                                       Understanding the Problem

* As a part of the Capstone Activity, which game to pick was my first and foremost priority.
* After i chose Hungry snake game, i tried to understand how the game works
* What the game needs, a snakeboard, snake and food for the snake.
* I came up with how to drive the game
* I figured out what conditions should be set to my game to work better.
* What will be the ending of the game
* Understanding the conditions to be met to end the game


                                       Planning the Solution

*   Which design pattern should i use in my project to cope up with my game that i chose.
*   Make sure my project has one Interface, one Abstract class, one lamda expression to meet the core requirements.
*   Initially i worked out designing a terminal game, and plan to switch to GUI.
*   Created one interface for my constants.
*   Another interface for checkForCollision method, that i implemented in food and snake classes.




                                        Executing the Plan

* Singleton pattern is implemented successfully that perfectly fitted in  my project.
* Implemented the interface in my project
* Extended my Abstact class methods and overridden in child classes
* Since i used Singleton, i am allowed to create only one object for my classes and reuse them if necessary.
* I have taken Pixel class as an abstract class
* My Food and Snake class extends this Pixel and implents my GameAcitions interface.
* checkForCollision method i implemented in two different classes for different purposes


                                        Reflection / Refactor

* Firstly, i designed my game in such a way that it takes user input for taking each step, and i refactor my code in such a way that it supports the GUI features and at the same time meeting all the other core requirements as well.

